## 终端和进程组

init-->fork-->exec-->getty-->用户输入账号-->login-->输入密码-->exec-->shell

用户通过终端进入自己的shell程序

/dev下的tty是个泛型指针，当前进程的PCB里记录了自己的控制终端名

##### 网络终端

由服务器来模拟一个为伪终端，通过exec login, exec bash来创建终端



### 进程组

用来获得当前进程组ID的函数

* getpgrp（BSD实现）
* getpgid

组长进程标志：其进程组ID == 其进程ID

组长进程可以创建一个进程组，创建该进程组中的进程，然后终止，只要进程组中有一个进程存在，进程组就存在

进程组生存期：进程组创建的最后一个进程离开

设置进程组ID的函数

* setpgid
  * 改变子进程为新的组，应当在fork之后，exec之前
  * 非root进程只能改变自己创建的子进程，或自己有权限的进程



### 会话

SID session id

SIGHUP信号：当用户退出shell时，由该shell进程启动的所有的进程（根据SID）将收到这个信号，默认终止进程

一个shell进程所创建的所有进程都位于都一个会话组

##### 设置会话组id

* setsid
  * 调用进程不能是进程组组长，该进程变成新会话首进程，新组组长
  * 需要有root权限
  * 新会话会丢弃控制终端，该会话没有控制终端
  * 调用进程是组长的话会返回出错
  * 建立新会话时，先调用fork，父进程终止（因为父进程不能设置新会话），然后设置新进程为新会话

##### 获得指定进程的会话id

* getsid



### 守护进程

Daemon进程，是linux中的后台服务程序，生存周期长，没有控制终端，周期性地去执行某些任务



##### 守护进程的创建步骤

* 创建子进程，父进程退出，所有工作放在子进程，形式上脱离了控制终端
* 在子进程中创建新会话
* 改变当前目录为根目录 chdir（防止占用可卸载的文件系统）
* 重设文件权限掩码 umask
* 关闭文件描述符（没有终端，就没有输入和输出和错误流了）
* 开始执行守护进程核心工作
* 退出守护进程



